package edu.ucla.cs.cve.download;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.io.FileUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class CVEPatchCrawler {
		
	public void crawlPatches(String cveFilePath, String outputDir) throws ParserConfigurationException, SAXException, IOException {
		File cveFile = new File(cveFilePath);
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		dbf.setNamespaceAware(true);
		DocumentBuilder builder = dbf.newDocumentBuilder();
		Document doc = builder.parse(cveFile);
		NodeList cveEntries = doc.getDocumentElement().getElementsByTagNameNS("*", "entry");
		ArrayList<String> cves = new ArrayList<String>();
		HashMap<String, HashSet<String>> patchUrls = new HashMap<String, HashSet<String>>(); 
		for(int i = 0; i < cveEntries.getLength(); i++) {
			Node entry = cveEntries.item(i);
			String cveId = entry.getAttributes().getNamedItem("id").getNodeValue();
//			System.out.println(cveId);
			cves.add(cveId);
			Element e = (Element)entry;
			NodeList refs = e.getElementsByTagNameNS(CVESchema.vulnNS, "reference");
			for(int j = 0; j < refs.getLength(); j++) {
				Element ref = (Element) refs.item(j);
				String link = ref.getAttribute("href");
				if(link.contains("github") && (link.contains("/commit/") || link.contains("/pull/"))) {
//				if(link.contains("github") && link.contains("/commit/")) {
//				if(link.contains("github") && link.contains("/pull/")) {
//					System.out.println(link);
					HashSet<String> links;
					if(patchUrls.containsKey(cveId)) {
						links = patchUrls.get(cveId);
					} else {
						links = new HashSet<String>();
					}
					
					// normalize GitHub links
					if(link.contains("/pull/") && link.endsWith("/files")) {
						link = link.substring(0, link.length() - 6);
					} else if (link.contains("/commit/") && link.endsWith(".patch")) {
						link = link.substring(0, link.length() - 6);
					} else if (link.contains("/pull/") && link.contains("/commits")) {
						link = link.substring(0, link.indexOf("/commits"));
					} else if (link.equals("https://github.com/ignacionelson/ProjectSend/compare/448/commits")) {
						link = "https://github.com/ignacionelson/ProjectSend/pull/448";
					} else if (link.endsWith("/")) {
						link = link.substring(0, link.length() - 1);
					}
					
					links.add(link);
					patchUrls.put(cveId, links);
				}
			}
		}
		
		System.out.println("Total Num of CVEs: " + cves.size());
		System.out.println("Total Num of CVEs with GitHub patches: " + patchUrls.keySet().size());
		
		// comment out the following part since we have downloaded all patches
		for(String id : patchUrls.keySet()) {
			File dir = new File(outputDir + File.separator + id);
			if(!dir.exists()) {
				dir.mkdir();
			}
			
			int count = 0;
			for(String link : patchUrls.get(id)) {
				String filePath = outputDir + File.separator + id + File.separator + count + ".txt";
				
				if(link.equals("https://github.com/LimeSurvey/LimeSurvey/pull/331")) {
					// diff too large to download
					continue;
				}
				System.out.println("Downloading " + link);
				String patch = DownloadUtils.download(link + ".patch");
				if(!patch.isEmpty() || patch.split(System.lineSeparator()).length > 5) {
					String content = link + System.lineSeparator();
					content += patch;
					FileUtils.write(new File(filePath), content, Charset.defaultCharset(), false);
					count++;
				}
			}
		}
	}
		
	public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
		String patchRootPath = "/home/troy/ONR/CVE-patches";
		for(int year = 2002; year < 2019; year++) {
			String filePath = "/home/troy/ONR/CVE-data/nvdcve-2.0-" + year + ".xml";
			File dir = new File(patchRootPath + File.separator + year);
			if(!dir.exists()) {
				dir.mkdir();
			}
			
			System.out.println("===" + year + "===");
			CVEPatchCrawler crawler = new CVEPatchCrawler();
			crawler.crawlPatches(filePath, dir.getAbsolutePath());
		}
	}
}
